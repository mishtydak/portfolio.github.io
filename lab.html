<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <title>Portfolio Website</title>
    <style>
        h2 {
            font-size: 28px; /* Increase the size of headings */
            margin-bottom: 10px; /* Add some spacing below headings */
        }
        ul, li {
            font-size: 18px; /* Increase the size of list items */
            line-height: 1.8; /* Add spacing between lines for better readability */
        }
        p {
            font-size: 18px; /* Increase the size of paragraphs */
        }
        a {
            text-decoration: none; /* Optional: Remove underline from links */
            color: #0066cc; /* Optional: Add a nice color to links */
        }
        d4 {
            font-size: 30px; /* Adjust this value to increase the size */
            line-height: 1.8; /* Optional: Increase spacing between lines */
        }
        d4 dt {
            font-weight: bold; /* Optional: Make definition terms bold */
        }
        d4 dd {
            margin-left: 20px; /* Optional: Add spacing to the descriptions */
        }
    </style>
</head>
<body>
    <header>
        <a href="#" class="logo">DAA</a>
    </header>
    <section class="home">
        <div class="home-content">
            <a href="theory.html" class="btn">THEORY</a>
            <a href="lab.html" class="btn">LAB</a>
            <h2>LAB Reflections</h2>
            <h2>1. Time complexity analysis</h2>
            <p style="color: white;">
                1. Challenges in Understanding Time Complexity<br>
                - Grasping asymptotic notations (\(O, \Omega, \Theta\)) and their meanings.<br>
                - Analyzing loops, recursion, and breaking algorithms into steps.<br><br>   

                2. Challenges in Correlating with Real-World Applications<br>
                - Choosing the right algorithm based on input size and constraints.<br><br>

                3. Determining the Efficient Approach<br>
                - Analyze problem constraints and input size.<br>
                - Test and profile algorithms to validate theoretical efficiency.
            </p>
            <h2>2. Binary Search Tree</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding BSTs<br>
                - Picture a family tree but for data. Visualizing how nodes are connected can be tricky at first.<br>
                - Learning to navigate through the tree in different ways (like visiting every room in a house in a specific order).<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - It's like learning a new game without seeing it played in real life. Connecting theory to practice takes time.<br>
                - Understanding how fast your BST operations are in the real world can be like comparing race cars' speeds on different tracks.<br>
                - Ensuring the BST remains efficient as it grows.<br><br>

                3. Determining the Most Efficient Approach<br>
                - First, figure out if your problem involves ordered data or frequent searches—like deciding if you need a grocery list or a scavenger hunt.<br>
                - Compare BST with other data structures to see which fits best—like choosing the right tool for a job.<br>
                - Collaborate with others to get new insights—like asking friends to taste-test your dish.
                bst code
                #include<iostream>
#include<cstdlib>
//#define NULL 0
using namespace std;

struct tree
{
    int data;
    struct tree*left;
    struct tree *right;
};
typedef struct tree TREE;


class binarysearchtree
{
public:
    TREE*insert_into_bst(TREE*,int);
    void inorder(TREE*);
    void preorder(TREE*);
    void postorder(TREE*);
    int total_nodes(TREE* );
    void printOutDegreeOfRoot(TREE* root);
    TREE* delete_from_bst(TREE*, int);
    TREE* delete_less_than_k(TREE*,int);
    void minimum(TREE*);
    void maximum(TREE*);
    int GreaterThanK(TREE*,int);
    int LesserThanK(TREE*,int);
};
void binarysearchtree::minimum(TREE* root){
   int Min=root->data;
   while(root->left!=NULL) root=root->left;
   Min=root->data;
   cout<<"Min value is "<<Min<<endl;
}
int binarysearchtree::GreaterThanK(TREE* root,int k){
   int sum=0;
   if(root==NULL){
    return 0;
   }
   if(root->data==k) return total_nodes(root->right);
   else if(root->data>k){
    sum=total_nodes(root->right)+1;
    sum=sum+GreaterThanK(root->left,k);
    return sum;
   }
   else{
    return GreaterThanK(root->right,k);
   }
}

int binarysearchtree::LesserThanK(TREE* root,int k){
   int sum=0;
   if(root==NULL) return 0;
   if(root->data==k) return total_nodes(root->left);
   else if(root->data<k){
    sum=1+total_nodes(root->left);
    sum=sum+LesserThanK(root->right,k);
    return sum;
   }
   else{
    return LesserThanK(root->left,k);
   }
}

void binarysearchtree::maximum(TREE* root){
   int Max=root->data;
   while(root->right!=NULL) root=root->right;
   Max=root->data;
   cout<<"Max value is "<<Max<<endl;
}
TREE* binarysearchtree::delete_less_than_k(TREE* root,int k){
   if(root==NULL) return root;
   root->left=delete_less_than_k(root->left,k);
   root->right=delete_less_than_k(root->right,k);
   if(root->data<k){
    TREE* temp=root->right;
    root=delete_from_bst(root,root->data);
   }
   return root;
}
TREE* binarysearchtree::insert_into_bst(TREE* root,int data)
{
    TREE* newnode=(TREE*)malloc(sizeof(TREE));
    if(newnode==NULL)
    {
        cout<<"memory allocation failed\n";
        return root;
    }

    newnode->data=data;
    newnode->left=NULL;
    newnode->right=NULL;

    if(root==NULL)
    {
        root=newnode;
        cout<<"root node inserted into tree\n";
        return root;
    }

    TREE*currnode=root;
    TREE* parent=NULL;

    while(currnode!=NULL)
    {
        parent=currnode;
        if(newnode->data<currnode->data)
            currnode=currnode->left;
        else
            currnode=currnode->right;
    }


    if(newnode->data<parent->data)
        parent->left=newnode;
    else
        parent->right=newnode;
    cout<<"node inserted successfully into the tree"<<endl;
    return root;
}

void binarysearchtree::inorder(TREE* root)
{
    if(root!=NULL)
    {
        inorder(root->left);
        cout<<root->data<<"\t";
        inorder(root->right);
    }
}

void binarysearchtree::preorder(TREE* root)
{
    if(root!=NULL)
    {
        cout<<root->data<<"\t";
        preorder(root->left);
        preorder(root->right);
    }
}

void binarysearchtree::postorder(TREE* root)
{
    if(root!=NULL)
    {
        postorder(root->left);
        postorder(root->right);
        cout<<root->data<<"\t";
    }
}

TREE* binarysearchtree::delete_from_bst(TREE* root,int data)
{
    TREE* currnode=root;
    TREE* parent =NULL;
    TREE* successor =NULL;
    TREE* p=NULL;

    if(root==NULL)
    {
        cout<<"tree is empty\n";
        return root;
    }
    while(currnode!=NULL&&currnode->data!=data)
    {
        parent=currnode;
        if(data<currnode->data)
            currnode=currnode->left;
        else
            currnode=currnode->right;
    }
    if(currnode==NULL)
    {
        cout<<"item not found\n";
        return root;
    }
    if(currnode->left==NULL)
        p=currnode->right;
    else if(currnode->right==NULL)
        p=currnode->left;
    else{
        successor=currnode->right;
        while(successor->left!=NULL)
            successor=successor->left;
        successor->left=currnode->left;
        p=currnode->right;
    }

    if(parent==NULL)
    {
        free(currnode);
        return p;
    }
    if(currnode==parent->left)
        parent->left=p;
    else
        parent->right=p;
     free(currnode);
    return root;
}
int binarysearchtree::total_nodes(TREE* root){
   if(root==NULL) return 0;
   return 1+total_nodes(root->left)+total_nodes(root->right);
}
void binarysearchtree::printOutDegreeOfRoot(TREE* root){
   if(root->left==NULL&&root->right==NULL) cout<<"Out degree of root node = 0\n";
   else if(root->left!=NULL&&root->right!=NULL) cout<<"Out degree of root node = 2\n";
   else cout<<"Out degree of root node = 1\n";
}

int main()
{
    binarysearchtree bst;
    TREE* root=NULL;
    int ch=0,k;
    int data=0;
    while(1)
    {
        cout<<"\n menu\n";
        cout<<"1-insert into bst\n";
        cout<<"2-inorder traversal\n";
cout<<"3-preorder traversal\n";
cout<<"4-postorder traversal\n";
cout<<"5-delete from bst\n";
cout<<"6-total number of nodes\n";
cout<<"7-total number of edges\n";
cout<<"8-outdegree\n";
cout <<"9-Delete less than k\n";
cout <<"10-Minimum in the tree\n";
cout <<"11-Maximum in the tree\n";
cout <<"12-No. of nodes greater than k\n";
cout <<"13-No. of nodes lesser than k\n";
cout<<"enter your choice\n";
cin>>ch;
switch(ch)
{
    case 1:
                cout<<"enter the item to insert:";
                cin>>data;
                root=bst.insert_into_bst(root,data);
                break;
    case 2:
                if(root==NULL)
                    cout<<"tree is empty\n";
                else{
                    cout<<"inorder traversal is..\n";
                    bst.inorder(root);
                }
                break;
    case 3:
                if(root==NULL)
                    cout<<"tree is empty\n";
                else{
                    cout<<"preorder traversal is..\n";
                    bst.preorder(root);
                }
                break;
    case 4:
                if(root==NULL)
                    cout<<"tree is empty\n";
                else{
                    cout<<"postorder traversal is..\n";
                    bst.postorder(root);
                }
                break;
    case 5:
               cout<<"enter the item to be deleted:";
               cin>>data;
               root=bst.delete_from_bst(root,data);
                break;
    case 6:
                cout<<"total number of nodes "<<bst.total_nodes(root)<<endl;break;
    case 7:
                cout<<"total edges = "<<bst.total_nodes(root)-1<<endl;break;
    case 8:
                 bst.printOutDegreeOfRoot(root);break;
    case 9:
                cout<<"enter the value of k\n";
                 cin>>k;
                 root=bst.delete_less_than_k(root,k);
                 cout<<"deleted";
        break;
    case 10:
        bst.minimum(root);
        break;
    case 11:
        bst.maximum(root);
        break;
    case 12:
        cout<<"enter the value of k\n";
        cin>>k;
        cout<<"The no. of nodes greater than k = "<<bst.GreaterThanK(root,k);
        break;
    case 13:
        cout<<"enter the value of k\n";
        cin>>k;
        cout<<"The no. of nodes lesser than k = "<<bst.LesserThanK(root,k);
        break;
    default:
                cout<<"exiting code\n";
                exit(0);
        }
    }
    return 0;
}


            </p>
            <h2>Algorithmic Concepts</h2>
            <h2>3. DFS and BFS</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding DFS and BFS<br>
                - Grasping the depth-first (DFS) vs. level-wise (BFS) approach.<br>
                - Picturing traversal processes.<br>
                - Writing effective code, managing recursion for DFS and queues for BFS.<br>
                - Avoiding infinite loops in graphs with cycles.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting the theory to practical uses like web crawling or social network analysis.<br>
                - Evaluating efficiency in real-world scenarios.<br>
                - Applying algorithms to large-scale systems, like network routing.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify the problem type—depth exploration (DFS) vs. level exploration (BFS).<br>
                - Evaluate based on complexity and specific needs.<br>
                - Implement both, test, and compare.
            </p>
            <ul>
                <li><strong>Segment Tree:</strong> Handles range queries efficiently.</li>
                <li><strong>Fenwick Tree:</strong> Optimized for cumulative frequency queries.</li>
                <li><strong>Sparse Table:</strong> Precomputes answers for range queries.</li>
            </ul>
            <h2>4. Heap</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Heaps<br>
                - Understanding the binary tree representation of heaps.<br>
                - Grasping the min-heap and max-heap properties.<br>
                - Writing efficient code for insertion, deletion, and heapify operations.<br>
                - Visualizing the heap structure and operations.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting heap concepts to real-world uses like priority queues and scheduling.<br>
                - Evaluating efficiency in practical scenarios.<br>
                - Applying heaps to large-scale data processing tasks.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify if the problem requires a priority-based approach.<br>
                - Evaluate heap against other data structures for suitability.<br>
                - Implement and test the heap operations.
            </p>
            <h2>5. Sorting</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Sorting Algorithms<br>
                - Understanding the logic behind different algorithms like Quick Sort, Merge Sort, and Heap Sort.<br>
                - Grasping the time and space complexity trade-offs for each algorithm.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting sorting concepts to tasks like organizing large datasets or ranking search results.<br>
                - Handling real-world constraints, such as memory limitations or specific ordering rules.<br><br>

                3. Determining the Efficient Approach<br>
                - Test and evaluate the chosen algorithm on real-world scenarios to ensure performance and reliability.
            </p>
            <h2>6. Pattern Searching</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Pattern Searching Concepts<br>
                - Understanding logic, time, and space complexities of algorithms like KMP or Rabin-Karp.<br>
                - Handling special cases like overlapping patterns or empty strings.<br>
                - Debugging: Errors in implementation, especially with indexing or hash collisions.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Applying theoretical concepts to areas like DNA sequencing or log analysis.<br>
                - Ensuring algorithms perform efficiently on large datasets.<br>
                - Dealing with noise or inconsistent patterns in real-world data.<br><br>

                3. Determining the Most Efficient Approach/Design Techniques<br>
                - Define objectives and constraints (e.g., exact vs. approximate matching).<br>
                - Compare based on time/space complexity (e.g., KMP for repetitive patterns, Boyer-Moore for large texts).<br>
                - Preprocess data, use parallelism for large datasets, or adopt dynamic programming for complex problems.
            </p>
            <h2>7. Graph Algorithms</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Graph Algorithms<br>
                - Grasping different graph representations like adjacency lists and matrices.<br>
                - Understanding traversal techniques like BFS, DFS, and their recursive/iterative implementations.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting graph algorithms to practical problems like shortest path calculation in GPS, network optimization, or social network analysis.<br>
                - Adapting algorithms to handle dynamic graphs or large-scale networks efficiently.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify the specific problem type (e.g., shortest path, minimum spanning tree, or connectivity).<br>
                - Compare algorithms based on their suitability for the problem (e.g., Dijkstra’s for non-negative weights, Bellman-Ford for graphs with negative weights).
            </p>
        </div>
    </section>
    <a href="theory.html" class="btn">HOME</a>
</body>
</html>
