<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <title>Portfolio Website</title>
    <style>
        h2 {
            font-size: 28px; /* Increase the size of headings */
            margin-bottom: 10px; /* Add some spacing below headings */
        }
        ul, li {
            font-size: 18px; /* Increase the size of list items */
            line-height: 1.8; /* Add spacing between lines for better readability */
        }
        p {
            font-size: 18px; /* Increase the size of paragraphs */
        }
        a {
            text-decoration: none; /* Optional: Remove underline from links */
            color: #0066cc; /* Optional: Add a nice color to links */
        }
        d4 {
            font-size: 30px; /* Adjust this value to increase the size */
            line-height: 1.8; /* Optional: Increase spacing between lines */
        }
        d4 dt {
            font-weight: bold; /* Optional: Make definition terms bold */
        }
        d4 dd {
            margin-left: 20px; /* Optional: Add spacing to the descriptions */
        }
    </style>
</head>
<body>
    <header>
        <a href="#" class="logo">DAA</a>
    </header>
    <section class="home">
        <div class="home-content">
            <a href="theory.html" class="btn">THEORY</a>
            <a href="lab.html" class="btn">LAB</a>
            <h2>LAB Reflections</h2>
            <h2>1. Time complexity analysis</h2>
            <p style="color: white;">
                1. Challenges in Understanding Time Complexity<br>
                - Grasping asymptotic notations (\(O, \Omega, \Theta\)) and their meanings.<br>
                - Analyzing loops, recursion, and breaking algorithms into steps.<br><br>   

                2. Challenges in Correlating with Real-World Applications<br>
                - Choosing the right algorithm based on input size and constraints.<br><br>

                3. Determining the Efficient Approach<br>
                - Analyze problem constraints and input size.<br>
                - Test and profile algorithms to validate theoretical efficiency.
            </p>
            <h2>2. Binary Search Tree</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding BSTs<br>
                - Picture a family tree but for data. Visualizing how nodes are connected can be tricky at first.<br>
                - Learning to navigate through the tree in different ways (like visiting every room in a house in a specific order).<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - It's like learning a new game without seeing it played in real life. Connecting theory to practice takes time.<br>
                - Understanding how fast your BST operations are in the real world can be like comparing race cars' speeds on different tracks.<br>
                - Ensuring the BST remains efficient as it grows.<br><br>

                3. Determining the Most Efficient Approach<br>
                - First, figure out if your problem involves ordered data or frequent searches—like deciding if you need a grocery list or a scavenger hunt.<br>
                - Compare BST with other data structures to see which fits best—like choosing the right tool for a job.<br>
                - Collaborate with others to get new insights—like asking friends to taste-test your dish.
            </p>
            <h2>Algorithmic Concepts</h2>
            <h2>3. DFS and BFS</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding DFS and BFS<br>
                - Grasping the depth-first (DFS) vs. level-wise (BFS) approach.<br>
                - Picturing traversal processes.<br>
                - Writing effective code, managing recursion for DFS and queues for BFS.<br>
                - Avoiding infinite loops in graphs with cycles.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting the theory to practical uses like web crawling or social network analysis.<br>
                - Evaluating efficiency in real-world scenarios.<br>
                - Applying algorithms to large-scale systems, like network routing.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify the problem type—depth exploration (DFS) vs. level exploration (BFS).<br>
                - Evaluate based on complexity and specific needs.<br>
                - Implement both, test, and compare.
            </p>
            <ul>
                <li><strong>Segment Tree:</strong> Handles range queries efficiently.</li>
                <li><strong>Fenwick Tree:</strong> Optimized for cumulative frequency queries.</li>
                <li><strong>Sparse Table:</strong> Precomputes answers for range queries.</li>
            </ul>
            <h2>4. Heap</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Heaps<br>
                - Understanding the binary tree representation of heaps.<br>
                - Grasping the min-heap and max-heap properties.<br>
                - Writing efficient code for insertion, deletion, and heapify operations.<br>
                - Visualizing the heap structure and operations.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting heap concepts to real-world uses like priority queues and scheduling.<br>
                - Evaluating efficiency in practical scenarios.<br>
                - Applying heaps to large-scale data processing tasks.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify if the problem requires a priority-based approach.<br>
                - Evaluate heap against other data structures for suitability.<br>
                - Implement and test the heap operations.
            </p>
            <h2>5. Sorting</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Sorting Algorithms<br>
                - Understanding the logic behind different algorithms like Quick Sort, Merge Sort, and Heap Sort.<br>
                - Grasping the time and space complexity trade-offs for each algorithm.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting sorting concepts to tasks like organizing large datasets or ranking search results.<br>
                - Handling real-world constraints, such as memory limitations or specific ordering rules.<br><br>

                3. Determining the Efficient Approach<br>
                - Test and evaluate the chosen algorithm on real-world scenarios to ensure performance and reliability.
            </p>
            <h2>6. Pattern Searching</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Pattern Searching Concepts<br>
                - Understanding logic, time, and space complexities of algorithms like KMP or Rabin-Karp.<br>
                - Handling special cases like overlapping patterns or empty strings.<br>
                - Debugging: Errors in implementation, especially with indexing or hash collisions.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Applying theoretical concepts to areas like DNA sequencing or log analysis.<br>
                - Ensuring algorithms perform efficiently on large datasets.<br>
                - Dealing with noise or inconsistent patterns in real-world data.<br><br>

                3. Determining the Most Efficient Approach/Design Techniques<br>
                - Define objectives and constraints (e.g., exact vs. approximate matching).<br>
                - Compare based on time/space complexity (e.g., KMP for repetitive patterns, Boyer-Moore for large texts).<br>
                - Preprocess data, use parallelism for large datasets, or adopt dynamic programming for complex problems.
            </p>
            <h2>7. Graph Algorithms</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Graph Algorithms<br>
                - Grasping different graph representations like adjacency lists and matrices.<br>
                - Understanding traversal techniques like BFS, DFS, and their recursive/iterative implementations.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting graph algorithms to practical problems like shortest path calculation in GPS, network optimization, or social network analysis.<br>
                - Adapting algorithms to handle dynamic graphs or large-scale networks efficiently.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify the specific problem type (e.g., shortest path, minimum spanning tree, or connectivity).<br>
                - Compare algorithms based on their suitability for the problem (e.g., Dijkstra’s for non-negative weights, Bellman-Ford for graphs with negative weights).
            </p>
        </div>
        <a href="theory.html" class="btn">HOME</a>
        <a href="ci.html" class="btn">COURSE PROJECT INFORMATION</a>
        <a href="lp.html" class="btn">COURSE LEARNING REFLECTIONS</a>
    </section>
</body>
</html>
